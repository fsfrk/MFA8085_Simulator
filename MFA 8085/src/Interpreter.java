import java.awt.MenuItem;import java.util.HashMap;import java.util.Map;public class Interpreter extends Thread {    private int position = 0x0000; // Aktuelle Position    private static int stack = 0xFC32; // Standart Stack Adresse    private Befehlsdatenbank befehl_db; // Alle angaben zu konkreten Befehlen    private String quellcode[][] = new String[0xFFFF][4]; // ram [0] = Befehl ;    // [1] = ziel ; [2] =    // quelle ; [3] =    // Label    private Map<String, Integer> labelmap = new HashMap<String, Integer>(); // Hier    // drin    // befinden    // sich    // die    // Labels    // und    // die    // dazugeh�rigen    // Zeilennummer    private Map<String, Byte> flagmap = new HashMap<String, Byte>(); // Decode    // flag in    // Byte    private CPU cpu;    private MenuItem item;    // //////////////////////////////////////////////////////////////////////////////////////////////////////    // /////////////////////////////////////Methoden/////////////////////////////////////////////////////////    @SuppressWarnings("static-access")    public Interpreter(Befehlsdatenbank befehl_db, String code, CPU cpu,	    MenuItem item) {// To-Do neumachen	String text[], sp[];	this.befehl_db = befehl_db;	this.cpu = cpu;	this.item = item;	if (System.getProperty("os.name").startsWith("Windows")) {	    text = code.split("\r\n");	} else {	    text = code.split("\n");	}	for (int i = 0; i < text.length; i++) {	    sp = text[i].split("\\s", 3);	    quellcode[i][0] = sp[0];	    if ((sp.length > 1) && (sp[1] != null) && (sp[1] != "")) {		sp = sp[1].split(",", 3);		quellcode[i][1] = sp[0];		if (sp.length > 1) {		    sp = sp[1].split("\\s", 2);		    quellcode[i][2] = sp[0];		} else {		    quellcode[i][2] = "";		    quellcode[i][3] = "";		}	    } else {		if ((sp = text[i].split("\\s[a-z|0-9]+", 1)).length != 0) {		    quellcode[i][1] = sp[0];		}		if ((sp = text[i].split("\\s[a-z|0-9]+", 1)).length != 0) {		    quellcode[i][1] = sp[0];		}	    }	    if (text[i].split(":", 2).length > 1) {		sp = text[i].split(":", 2);		labelmap.put(sp[1], i);		quellcode[i][3] = sp[1];	    } else {		quellcode[i][3] = "";	    }	}	position = 0;	for (byte i = 0; i < CPU.FLAG.length; i++) {	    flagmap.put(CPU.FLAG[i], i);	}	for (String speicher : CPU.REGISTER) {	    this.cpu.reg.put(speicher, (byte) 0);	}	this.cpu.reg.put("FLAG", (byte) 0);    }    @Override    @SuppressWarnings("static-access")    public void run() { // To-Do neumachen	if ((befehl_db == null) || (quellcode == null)) {	    GUI.errormessage("Interner Fehler", true);	} else {	    do {		if ((quellcode[position][0] != null)			&& !quellcode[position][0].equals("")) {		    try {			Thread.sleep((1 / cpu.Hz) * readcommandline() * 1000);		    } catch (InterruptedException e) {			interrupt();		    }		} else if (quellcode[position][0] == null) {		    interrupt();		}		position++;	    } while (!isInterrupted());	}	for (String sp : cpu.REGISTER) {	    cpu.reg.put(sp, (byte) 0);	}	item.setLabel("Interpreter OFF");    }    private byte readcommandline() {// To-Do neumachen	String befehl[];	Behelter wert1 = new Behelter(0), wert2 = new Behelter(0);	byte time = 0;	if (quellcode[position][0].equals("IN")		|| quellcode[position][0].equals("OUT")) {	    if (quellcode[position][0].equals("IN")) {		cpu.reg.put("A", cpu.in(Byte.parseByte(quellcode[position][1])));	    }	    if (quellcode[position][0].equals("OUT")) {		cpu.out(cpu.reg.get("A"),			Byte.parseByte(quellcode[position][1]));	    }	} else {	    befehl = befehl_db.getfunction(quellcode[position][0]);	    time = befehl_db.gettakt1(quellcode[position][0]);	    if (befehl[0].equals("j")) {		time = befehl_db.gettakt1(quellcode[position][0]);		time = (new Function((befehl[1].equals("n") ? true : false),			(byte) (short) (cpu.reg.get("FLAG") & (0xff >> flagmap			.get(befehl[4]))),			labelmap.get(quellcode[position][1])).action) ? time				: 0;	    } else {		if (!befehl[3].equals(" ")) {		    if (befehl[2].equals("r")			    || (cpu.reg.get(befehl[2]) != null)) {			if (cpu.reg.get(befehl[2]) != null) {			    wert1.setvalue(cpu.reg.get(befehl[2]));			    wert2.setvalue(Integer				    .parseInt(quellcode[position][2]));			} else {			    if (befehl[2].equals("r")) {				wert1.setvalue(cpu.reg					.get(quellcode[position][1]));			    } else {				wert1.setvalue(cpu.reg.get(befehl[2]));			    }			    if (befehl[4].equals("r")) {				wert2.setvalue(Integer.parseInt(					cpu.reg.get(quellcode[position][2])						.toString(), 16));			    }			    if (befehl[4].equals("n")) {				wert2.setvalue(Short.parseShort(					quellcode[position][2], 16));			    }			    if (befehl[4].matches("[1-9]")) {				wert2.setvalue(Integer.parseInt(befehl[4]));			    }			}		    }		}		if (befehl[2].equals("n")) {		    wert1.setvalue(Short.parseShort(quellcode[position][1], 16));		}		if (befehl[2].equals("r")) {		    cpu.reg.put(quellcode[position][1], (byte) wert2.wert);		}		new Function((short) wert2.wert, wert1, befehl[3], cpu.reg,			befehl_db.getflag(quellcode[position][0]));		if (cpu.reg.get(befehl[2]) != null) {		    cpu.reg.put(befehl[2], (byte) wert1.wert);		}		if (befehl[2].equals("r")) {		    cpu.reg.put(quellcode[position][1], (byte) wert1.wert);		}		if (befehl[0].equals("n")) {		    new Function();		}	    }	}	return time;    }    // //////////////////////////////////////////////////////////////////////////////////////////////////////    // /////////////////////////////////////Befehlsinterpretation////////////////////////////////////////////    public class Function {// To-Do neumachen	boolean action = false;	public Function() {	} // nop	public Function(boolean not, byte source, int label) // Jump	{	    position = (not) ? (source == 0 ? (position = label - 1) : position)		    : (source != 0 ? (position = label - 1) : position);	    action = (not) ? (source == 0 ? (true) : false)		    : (source != 0 ? (true) : false);	}	public Function(String jump, String quellcode[][], int label) // Call	{	    if (jump.equals("c")) {		stack++;		quellcode[stack][0] = position + "";		position = (short) (label - 1);	    } else {		position = Integer.parseInt(quellcode[stack][0]);		stack--;	    }	}	public Function(short source, Behelter target, String action,		Map<String, Byte> regmap, byte flag) // Rechner	{	    if (action.equals("=")) {		target.setvalue(source);	    }	    if (action.equals("+")) {		target.setvalue(target.wert + source);	    }	    if (action.equals("-")) {		target.setvalue(target.wert - source);	    }	    if (action.equals("|")) {		target.setvalue(target.wert | source);	    }	    if (action.equals("&")) {		target.setvalue(target.wert & source);	    }	    if (action.equals("^")) {		target.setvalue(target.wert ^ source);	    }	    if (action.equals("~")) {		target.setvalue(~source);	    }	    if (action.equals("<")) {		target.setvalue((source << 1) | (source >>> (7)));	    }	    if (action.equals(">")) {		target.setvalue((source >>> 1) | (source << (7)));	    }	    // Bei den Flags wird von rechts nach links gezehlt	    if ((byte) ((flag) & 8) != 0) // Zero Flag	    {		regmap.put(			"FLAG",			(target.wert & 0x00ff) == 0 ? (byte) (regmap				.get("FLAG") | 8)				: (byte) (regmap.get("FLAG") & 0x7f));	    }	    if ((byte) ((flag) & 32) != 0) {		regmap.put(			"FLAG",			(target.wert & 0x0100) != 0 ? (byte) (regmap				.get("FLAG") | 32)				: (byte) (regmap.get("FLAG") & 0xDF));	    }	    target.setvalue(target.wert & 0xff);	}    }    public class Behelter {// To-Do andere lösung	public int wert;	public Behelter(int wert) {	    this.wert = wert;	}	public void setvalue(int wert) {	    this.wert = wert;	}    }}